#!__ENV__ __PYTHON__

#
# 1. Read two .ridx files which were obtained from the same website in both language
# directions (l1 to l2 and l2 to l1).
# 2. Load the second file (l2 to l1) and keep the best candidate for every file in l2.
# 3. Load the first file (l1 to l2) and print only those lines for which the prediction
# of the best candidate for every file in l1 is the same than the one obtained in the
# second file.
#
# output format:
# num_doc_l1    [num_doc_l2:frequency]+
#
# Generate .ridx -> reverse index
#

import sys
import getopt
from operator import itemgetter
from collections import OrderedDict

def usage():
  # Parametros: .ridx_l1 .ridx_l2
  error = "USAGE: " + sys.argv[0] + " index_l1 index_l2\n"
  error += "WHERE\n"
  error += "   index_l1           file with extenxion .ridx (reverse index document) for the document alignment from language 1 (l1) to language 2 (l2)\n"
  error += "   index_l2           file with extenxion .ridx (reverse index document) for the document alignment from language 2 (l2) to language 1 (l1)\n"
  sys.exit(error)

path_file_ridx1 = None
path_file_ridx2 = None
method = None

####
## Aqui empieza el script.
####
# Manejando las opciones con getopt
try:
  opts, args = getopt.getopt(sys.argv[1:], "1:2:m:h", [])
except getopt.GetoptError, err:
  # print help information and exit:
  print str(err) # will print something like "option -a not recognized"
  usage()
  sys.exit(2)

# -d .dic
for o, a in opts:
  if o == "-1":
    path_file_ridx1 = a
  elif o == "-2":
    path_file_ridx2 = a
  elif o == "-m":
    if a == "intersection":
      method = 'i'
    elif a == "score-average":
      method = 's'
    else:
      sys.stderr.write("Wrong value for option '-m': "+a+"\n")
      usage()
  elif o == "-h":
    usage()
  else:
    sys.error("Unhandled option")
    usage()

if path_file_ridx1 == None:
  sys.stderr.write("Missing option '-1' specifying the path to the first *.ridx file\n")
  usage()
elif path_file_ridx2 == None:
  sys.stderr.write("Missing option '-2' specifying the path to the second *.ridx file\n")
  usage()

if method == None:
  file_ridx1 = open(path_file_ridx1, "r")
  for line_ridx1 in file_ridx1:
    sys.stdout.write(line_ridx1)

elif method == 'i':
  best_ridx2_inv = {}

  file_ridx2 = open(path_file_ridx2, "r")
  for line_ridx2 in file_ridx2:
    fields=line_ridx2.strip().split("\t");
    if len(fields) >= 2:
      field1=fields[1].split(":")
      if len(field1) == 2:
        best_ridx2_inv[int(field1[0])]=int(fields[0])
  file_ridx2.close()

  file_ridx1 = open(path_file_ridx1, "r")
  for line_ridx1 in file_ridx1:
    fields=line_ridx1.strip().split("\t");
    if len(fields) >= 2:
      field1=fields[1].split(":")
      if len(field1) == 2:
        if int(fields[0]) in best_ridx2_inv and  best_ridx2_inv[int(fields[0])] == int(field1[0]):
          print line_ridx1.strip()

elif method == 's':
  best_ridx2_inv = {}

  file_ridx2 = open(path_file_ridx2, "r")
  for line_ridx2 in file_ridx2:
    fields=line_ridx2.strip().split("\t");
    if len(fields) >= 2:
      for candidate_idx in range(1,len(fields)):
        field_n=fields[candidate_idx].split(":")
        if len(field_n) == 2:
          if int(field_n[0]) not in best_ridx2_inv:
            best_ridx2_inv[int(field_n[0])]={}
          best_ridx2_inv[int(field_n[0])][int(fields[0])]=field_n[1]
  file_ridx2.close()

  file_ridx1 = open(path_file_ridx1, "r")
  for line_ridx1 in file_ridx1:
    new_candidate_list = {}
    fields=line_ridx1.strip().split("\t")
    if len(fields) >= 2:
      for candidate_idx in range(1,len(fields)):
        field_n=fields[candidate_idx].split(":")
        if len(field_n) == 2:
          if int(fields[0]) in best_ridx2_inv and int(field_n[0]) in best_ridx2_inv[int(fields[0])]:
            average=(float(best_ridx2_inv[int(fields[0])][int(field_n[0])])+float(field_n[1]))/2
            new_candidate_list[field_n[0]]=average
          else:
            new_candidate_list[field_n[0]]=float(field_n[1])/2
    if len(new_candidate_list) > 1:
      sorted_candidates = OrderedDict(sorted(new_candidate_list.iteritems(), key=itemgetter(1), reverse=True))
      print fields[0]+"\t"+ "\t".join(['%s:%s' % (k,v) for k,v in sorted_candidates.iteritems()])
