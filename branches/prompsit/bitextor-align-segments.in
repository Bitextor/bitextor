#!__ENV__ __PYTHON__


# 1. Reading from STDIN a set of aligned documents. The input format is:
#   filename1	filename2	clean_text1_in_base64	clean_text2_in_base64
# 2. Text is cleaned and, for every aligned pair, both texts are dumped, in the same order in two temporary files. Every text block is sepparated to the previous one by a block:
#    <p>
#    <file lang="lang_id">file_name</file>
#    <p>
# 3. Running hunalign on the two temporary files
# 4. Removing unaligned segments and <p> mark
# 5. Identifying the filenames for every block of segments, and printing everything to the output
#
# Output format:
#   filename1    filename2    segment1    segment2    quality
#

import sys
import os
from optparse import OptionParser
import base64
import subprocess
import re
from tempfile import NamedTemporaryFile

reload(sys)
sys.setdefaultencoding("UTF-8")

def runAligner(filename1, filename2):
  # option -ppthresh=10?
  hunalign = ["__PREFIX__/bin/hunalign", "-text", "-realign", "/dev/null", filename1, filename2]
  p = subprocess.Popen(hunalign, stdout=subprocess.PIPE)
  for line in p.stdout:
    yield line.decode("utf-8")
  return

oparser = OptionParser(usage="usage: %prog [options] [doc_aligned_file]\n where [doc_aligned_file] is a file contining the list of aligned files provided by bitextor-align-documents.")
oparser.add_option("--lang1", help="Two-characters-code for language 1 in the pair of languages", dest="lang1", default=None)
oparser.add_option("--lang2", help="Two-characters-code for language 2 in the pair of languages", dest="lang2", default=None)

(options, args) = oparser.parse_args()

if options.lang1 == None:
  sys.stderr.write("Undefined value for language 1. Set this value by using the parameter \"--lang1\"")
  sys.exit(-1)

if options.lang2 == None:
  sys.stderr.write("Undefined value for language 2. Set this value by using the parameter \"--lang2\"")
  sys.exit(-1)

tmp_file1=NamedTemporaryFile(delete=False, dir="/tmp")
tmp_file2=NamedTemporaryFile(delete=False, dir="/tmp")

if len(args) == 0:
  reader = sys.stdin
elif len(args) == 1:
  reader = open(args[0],"r")

for line in reader:
  fields=line.strip().split("\t")
  filename1=fields[0]
  filename2=fields[1]
  encodedtext1=fields[2]
  encodedtext2=fields[3]
  tmp_file1.write("<p>\n<file lang=\""+options.lang1+"\">"+filename1+"</file>\n<p>\n")
  pipe1 = subprocess.Popen(["perl", "/home/espla/local/share/bitextor/splitsentences/split-sentences.perl"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr = open(os.devnull, "w"))
  parsed_text, errout = pipe1.communicate(base64.b64decode(encodedtext1))
  tmp_file1.write(parsed_text)

  tmp_file2.write("<p>\n<file lang=\""+options.lang2+"\">"+filename2+"</file>\n<p>\n")
  pipe2 = subprocess.Popen(["perl", "/home/espla/local/share/bitextor/splitsentences/split-sentences.perl"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr = open(os.devnull, "w"))
  parsed_text, errout = pipe2.communicate(base64.b64decode(encodedtext2))
  tmp_file2.write(parsed_text)
tmp_file1.close()
tmp_file2.close()

filenames=[]
for line in runAligner(tmp_file1.name, tmp_file2.name):
  hun_line=line.strip()
  if "<p>" not in line and "\t\t" not in hun_line and len(hun_line.split("\t"))>=2:
    if "<file " in hun_line:
      plain=re.sub("<[^>]*>", "", hun_line.strip())
      filenames=plain.split("\t")
    else:
      print "{0}\t{1}\t{2}".format(filenames[0], filenames[1], hun_line)
