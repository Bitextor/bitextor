#!__ENV__ __PYTHON__

#
# 1. File .lett is processed to obtain a representation of the structure formatted as a string (here called 'raspa'), containing both html tags and the number of words in the text blocks
# 2. The final represetntation is added to the output together with the input elements
#
# Final output format:
# language	encoding	mimetype	url	content(base_64)	raspa
#
# Generates a .lettr -> language encoded and typed text with raspa
#

  # Se decodifica el base64
import sys
import base64
import math
import fileinput
from HTMLParser import HTMLParser
from optparse import OptionParser

class Parser(HTMLParser):

  def __init__( self ):
    HTMLParser.__init__( self )
    self.script = 0
    self.output = []

  def handle_starttag( self, tag, attrs ):
    if tag == "script" or tag == "noscript":
      self.script = 1
    else:
      self.output.append("_" + tag + "_")

  def handle_data( self, data ):
    if self.script == 0:
      if data != "":
        nwords=len(data.split())
        if nwords > 0:
          #Replacing every word in text by a "_" symbol
          self.output.append("_"*int(math.log(nwords, 2)))

  def handle_endtag( self, tag ):
    if tag == "script" or tag == "noscript":
      self.script = 0
    else:
      self.output.append("_" + tag + "_")

oparser = OptionParser(usage="usage: %prog [filename]\nwhere filename is the path to the file with extension .lett (language encoded and typed text) (standard input is used if this argument is not provided)")
#oparser.add_option("-h", "--help", help="Shows this help message", default=True)
(options, args) = oparser.parse_args()

if len(args) > 0:
  reader = open(args[0],"r")
else:
  reader = sys.stdin

for line in reader:
  content=line.strip().split("\t")
  e = base64.b64decode(content[4])
  if e != "":
    p=Parser()
    p.feed(e)
    print line.strip()+"\t"+"".join(p.output)
