#!__BASH__

INPUT=/dev/stdin
OUTPUT=/dev/stdout
LOG=$(mktemp /tmp/logbitextorlett2lettr.XXXXXX)

exit_program()
{
  echo "USAGE: $1 [file]"
  echo "WHERE"
  echo "   file   file with extension .lett (language encoded and typed text) (standard"
  echo "          input by default)"
  exit 1
}

ARGS=$(getopt "h" $*)

set -- $ARGS
for i
do
  case "$i" in
    -h)
      exit_program $(basename $0)
      ;;
    --)
      shift
      break
      ;;
  esac
done

case $# in
  0)
    ;;
  1)
    INPUT="$1"
    ;;
  *)
    exit_program $(basename $0)
    ;;
esac



# Código aquí

#
# 1. Se recorre el .lett y se llama a raspa
# 2. Sobre el .lett se coge el base64 y se saca una cadena formada sólo por
#    las etiquetas HTML que forman el documento
# 3. Se modifica el .lett añadiendo el campo raspa
#
# Formato final del documento:
# language	encoding	mimetype	url	content(base_64)	raspa
#
# Genera .lettr -> language encoded and typed text with raspa
#

raspa()
{
  # Se coge el base64
  __GAWK__ '{print $5}' | \
  # Se decodifica el base64
  __PYTHON__ -c '
import sys
import base64
import math
from HTMLParser import HTMLParser

def contar_palabras( data ):
  return len(data.split())

class Parser(HTMLParser):

  def __init__( self ):
    HTMLParser.__init__( self )
    self.script = 0

  def handle_starttag( self, tag, attrs ):
    if tag == "script" or tag == "noscript":
      self.script = 1
    else:
      sys.stdout.write("_" + tag + "_")

  def handle_data( self, data ):
    if self.script == 0:
      if data != "":
        palabras = contar_palabras(data)
        if palabras > 0:
          #sys.stdout.write(str(palabras))
          for j in range(int(math.log(palabras, 2))):
            sys.stdout.write("_")

  def handle_endtag( self, tag ):
    if tag == "script" or tag == "noscript":
      self.script = 0
    else:
      sys.stdout.write("_" + tag + "_")

for i in sys.stdin:
  e = base64.b64decode(i)
  if e != "":
    Parser().feed(e)
' 2>> $LOG
}

# Se recorren las líneas del fichero de entrada y, en la función raspa, pasa cada fichero a un
# formato preparado para distancia de edición.
cat $INPUT | \
while read line;
do
  RASPA="$(echo "$line" | raspa)"
  if !(test -z $RASPA);
  then
    echo $line | __GAWK__ -v raspa="$RASPA" '{print $1 "\t" $2 "\t" $3 "\t" $4 "\t" $5 "\t" raspa;}' >> $OUTPUT
  else
    echo "ERROR: RASPA VACÍA - $RASPA	$line" >> $LOG
  fi
done

