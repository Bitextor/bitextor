#!__ENV__ __PYTHON__

#
# 1. Leer .idx extrayendo palabras en las dos lenguas
# 2. Traducir palabras en los segundos documentos
# 3. Hacer interseccion entre cada par de documentos
# 4. Se muestran los 10 documentos de la segunda lengua mas parecidos a cada
#    uno de la primera
#
# Formato final del documento:
# num_doc_lang1    [num_doc_lang2:frequency]+
#
# Genera .ridx -> reverse index
#

import sys
import getopt
from sets import Set
from collections import defaultdict
from operator import itemgetter

def usage():
  # Parametros: .idx .dic lang1 lang2
  error = "USAGE: " + sys.argv[0] + " [-d dictionary] lang1 lang2 [index]\n"
  error += "WHERE\n"
  error += "   -d dictionary   file with extension .dic Dictionary with pair of selected\n"
  error += "                   languages. (installed dictionary at\n"
  error += "                   /home/espla/local/share/bitextor/diccionario.dic by default)\n"
  error += "   lang1           selected language with two letters code: en, es, fr, de ...\n"
  error += "   lang2           selected language with two letters code: en, es, fr, de ...\n"
  error += "   index           file with extenxion .idx (index document)\n"
  error += "                   (standard input by default)\n"
  sys.exit(error)

#
# Se rellenan los indices de palabras en las dos lenguas a partir del
# .idx de la entrada.
#
def rellenarIndex(file, lang1, lang2, index1, index2):
  for i in file:
    campos = i.strip().split("\t")
    if len(campos) == 3:
      if campos[0] == lang1 or campos[0] == lang2:
        documentos = campos[2].split(":")
        acum = 1

        for j in documentos:
          acum += int(j)
          if campos[0] == lang1:
            index1[acum].add(campos[1])
          else:
            index2[acum].add(campos[1])
  file.close()

#
# Se cargan los dos diccionarios en las dos lenguas a partir del .dic de la entrada.
#
def cargarDiccionarios(diccionario, lang1, lang2, dic):
  col_dic1 = -1
  col_dic2 = -1
  file = open(diccionario, "r")
  campos = file.readline().strip().split("\t")
  ind = 0
  for j in campos:
    if j == lang1:
      col_dic1 = ind
    elif j == lang2:
      col_dic2 = ind
    ind += 1
  for i in file:
    campos = i.strip().split("\t")
    dic[campos[col_dic2]].append(campos[col_dic1])

#
# En el segundo documento, se traducen las palabras encontradas en el
# diccionario de su idioma por las equivalentes en el otro idioma.
# Esto se hace para todos los documentos encontrados en el segundo idioma.
#
def traducirPalabras(index, dic, dictp, translatedindex):
  for i in index:
    translatedindex[i] = Set([])
    contador = 0
    for word in index[i]:
      if word in dic:
        contador += 1
        translatedindex[i].update(dic[word])
    dictp[i] = contador


####
## Aqui empieza el script.
####
# Manejando las opciones con getopt
try:
  opts, args = getopt.getopt(sys.argv[1:], "d:h", [])
except getopt.GetoptError, err:
  # print help information and exit:
  print str(err) # will print something like "option -a not recognized"
  usage()
  sys.exit(2)

# -d .dic
for o, a in opts:
  if o == "-d":
    diccionario = a
  elif o == "-h":
    usage()
  else:
    sys.error("Unhandled option")
    usage()

# Parametros: lang1 lang2 [.idx]
if (len(args) == 2 or len(args) == 3):

  index_text1 = defaultdict(set)
  index_text2 = defaultdict(set)
  dic = defaultdict(list)
  lista_palabras = []
  encontrados = {}
  dict_palabras = {}
  translated_index_text2 = {}

  # Manejando los argumentos
  lang1 = args[0]
  lang2 = args[1]

  cargarDiccionarios(diccionario, lang1, lang2, dic)

  if len(args) == 3:
    index_palabras = args[2]
    rellenarIndex(open(index_palabras, "r"), lang1, lang2, index_text1, index_text2)
  else:
    rellenarIndex(sys.stdin, lang1, lang2, index_text1, index_text2)

  #
  # Para cada par de documentos, tras llamar a traducirPalabras, se realiza una
  # interseccion entre ellos y se divide por el numero de palabras traducidas en
  # ese documento en la funcion traducirPalabras. El resultado de la interseccion
  # entre el numero de palabras traducidas en traducirPalabras dara un
  # porcentaje de cuanto se parecen eso documentos. Se muestra una lista con
  # los 10 documentos mas parecidos a cada uno de ellos.
  #
  traducirPalabras(index_text2, dic, dict_palabras, translated_index_text2)

  for i in index_text1:
    parecidos = {}
    for j in index_text2:
#      c3 = filter(lambda x: x in translated_index_text2[j], index_text1[i])
      c3 = index_text1[i].intersection(translated_index_text2[j])
      if len(c3) > 0 and int(dict_palabras[j]) > 0:
        max_vocab=max(len(index_text1[i]),len(index_text2[j]))
        min_vocab=min(len(index_text1[i]),len(index_text2[j]))
        num_intersect_words=len(c3)
        num_trans_words_text2=dict_palabras[j]
        parecidos[j] = (float(min_vocab)/float(max_vocab))*(float(num_intersect_words)/float(num_trans_words_text2))

    if len(parecidos) > 0:
      parecidos = sorted(parecidos.items(), key=itemgetter(1), reverse=True)
    encontrados[i] = []
    for j in parecidos:
      encontrados[i].append(str(j[0]) + ":" + str(j[1]))

  # Se saca el numero de documento y sus 10 mas parecidos.
  for i in encontrados:
    if len(encontrados[i]) > 10:
      contador = 10
    else:
      contador = len(encontrados[i])
    primera = True
    cadena = str(i) + "\t"
    for j in range(contador):
      if primera == True:
        cadena += str(encontrados[i][j])
        primera = False
      else:
        cadena += "\t" + str(encontrados[i][j])
    print cadena

else:
  usage()

