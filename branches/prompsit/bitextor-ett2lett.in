#!__BASH__

INPUT=/dev/stdin
OUTPUT=/dev/stdout
LOG=$(mktemp /tmp/logbitextorett2lett.XXXXXX)

exit_program()
{
  echo "USAGE: $1 [file]"
  echo "WHERE"
  echo "   file   file with extension .ett (encoded and typed text) (standard"
  echo "          input by default)"
  exit 1
}

ARGS=$(getopt "h" $*)

set -- $ARGS
for i
do
  case "$i" in
    -h)
      exit_program $(basename $0)
      ;;
    --)
      shift
      break
      ;;
  esac
done

case $# in
  1)
    INPUT="$1"
    ;;
  0)
    ;;
  *)
    exit_program $(basename $0)
    ;;
esac

# Código aquí

#
# 1. Leer .ett línea a línea
# 2. Llama a la función detectar_idioma_linea
# 3. Se decodifica el campo base64 y se quita HTML
# 4. Detectar idioma con text_cat, si hay error -> (log)
# 5. Crea .lett, si no detecta idioma -> (log)
#
# Formato final del documento:
# language	encoding	mimetype	url	content(base_64)
#
# Genera .lett -> language encoded and typed text
#

# Se recorren las líneas del fichero de entrada y se detecta su idioma para cada una de
# ellas.
cat $INPUT | \
  __PYTHON__ -c '
import sys
import base64
from HTMLParser import HTMLParser
import langid

#Class for parsing the XHTML files
class Parser(HTMLParser):

  def __init__( self ):
    HTMLParser.__init__( self )
    self.script = 0
    self.output = []

  def handle_starttag( self, tag, attrs ):
    if tag == "script" or tag == "noscript":
      self.script = 1

  def handle_data( self, data ):
    if self.script == 0:
      self.output.append(data)

  def handle_endtag( self, tag ):
    if tag == "script" or tag == "noscript":
      self.script = 0

#Reading line by line from the standard output
for line in sys.stdin:
  linefields=line.split()
  #decoding the b64 original webpage
  e = base64.b64decode(linefields[3]).replace("\n", " ")
  p=Parser()
  p.feed(e)
  #detecting language
  lang, conf = langid.classify(" ".join(p.output))
  sys.stdout.write("{0}\t{1}".format(lang, line))

' 2>> $LOG >> $OUTPUT
