#!__ENV__ __PYTHON__

#
# 1. Read lines from .ett file
# 2. For eac line, the HTML is cleaned and the language is detected for the raw text
# 3. Output is printed following the format:
#
# language	encoding	mimetype	url	content(base_64)
#
#

import sys
import base64
from HTMLParser import HTMLParser
import langid
from optparse import OptionParser

#Class for parsing the XHTML files
class Parser(HTMLParser):

  def __init__( self ):
    HTMLParser.__init__( self )
    self.script = 0
    self.output = []

  def handle_starttag( self, tag, attrs ):
    if tag == "script" or tag == "noscript":
      self.script = 1

  def handle_data( self, data ):
    if self.script == 0:
      self.output.append(data)

  def handle_endtag( self, tag ):
    if tag == "script" or tag == "noscript":
      self.script = 0

oparser = OptionParser(usage="usage: %prog [filename]\nwhere filename is the path to the file with extension .ett (language encoded and typed text) (standard input is used if this argument is not provided)")
oparser.add_option("-l", "--languages", help="List accepted languages represented as a comma separated language codes list", dest="langlist", default=None)
(options, args) = oparser.parse_args()

lags=[]
if options.langlist != None:
  langs=options.langlist.strip().split(",")

if len(args) > 0:
  reader = open(args[0],"r")
else:
  reader = sys.stdin

#Reading line by line from the standard output
for line in reader:
  linefields=line.split()
  #decoding the b64 original webpage
  e = base64.b64decode(linefields[3]).replace("\n", " ")
  p=Parser()
  p.feed(e)
  #detecting language
  lang, conf = langid.classify(" ".join(p.output))
  if len(langs)>0 and lang in langs:
    sys.stdout.write("{0}\t{1}".format(lang, line))
