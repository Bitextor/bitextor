#!__ENV__ __PYTHON__

#
# 1. Leer .lettr y cargarlo en memoria
# 2. Leer .ridx e ir haciendo distancia de edicion
# 3. Con el porcentaje de parecido anterior y el nuevo se realiza:
#      nuevo_porcentaje = ant_porcentaje * dist_porcentaje
#    donde:
#      dist_porcentaje = longitud(raspa1) / (longitud(raspa1) + dist)
# 4. Se muestran los 10 documentos con los porcentajes actualizados
#
# Formato final del documento:
# num_doc_lang1    [num_doc_lang2:ratio]+
#
# Genera .ridx -> reverse index
#

import sys
import getopt
from operator import itemgetter
import Levenshtein

def rellenarDocumentos(fich, documentos):
  file = open(fich, "r")
  contador = 1
  for i in file:
    campos = i.split("\t")
    if len(campos) == 7:
      documentos[contador] = campos[6]
    contador += 1
  file.close()

oparser = OptionParser(usage="usage: %prog [filename]\nwhere filename is the path to the file with extension .ridx (reverse index of documents) (standard input is used if this argument is not provided)")
oparser.add_option("-l", "--lettr", help=".lettr (language encoded and typed text with \"raspa\") file with all the information about the processed files (.lett file is also valid)", dest="lettr", default=None)
(options, args) = oparser.parse_args()

if options.lettr != None:
  sys.stderr.write("Error: it is necessary to specify the path to the LETTR file containing the information about the processed documents.")
  sys.exit(-1)

if len(args) > 0:
  reader = open(args[0],"r")
else:
  reader = sys.stdin

index = {}
documentos = {}
rellenarDocumentos(fich, documentos)

for i in reader:
  campos = i.split("\t")
  longitud_s = len(documentos[int(campos[0])])
  parecidos = {}
  cadena = str(campos[0])
  for j in range(1,len(campos)-1):
    doc = campos[j].split(":")
    if float(doc[1]) > 0.10:
      longitud_t = len(documentos[int(doc[0])])
      dist = Levenshtein.distance(documentos[int(campos[0])],documentos[int(doc[0])])
      port = 1 - (dist / float(max(longitud_s, longitud_t)))
      ##port = float((min(len(documentos[int(campos[0])]),len(documentos[int(doc[0])]))/float(max(len(documentos[int(campos[0])]),len(documentos[int(doc[0])]))))*(longitud / float(longitud + dist)))
      #new_per = (float(doc[1]) + port)/2.0
      #new_per = port
      new_per = float(doc[1]) * port
      parecidos[doc[0]] = new_per
  parecidos = sorted(parecidos.items(), key=itemgetter(1), reverse=True)
  for k in parecidos:
    cadena += "\t" + str(k[0]) + ":" + str(k[1])
  print cadena
