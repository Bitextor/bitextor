# nohup snakemake --configfile config.hieu.json --cluster "sbatch {cluster.gres}" --cluster-config cluster.json -j 1111 --cores 1111 -k &

import gzip
import lzma
import tldextract
import os.path
from tld import get_tld
from tqdm import tqdm
from collections import defaultdict
from contextlib import contextmanager
from pathlib import Path

###########################################################
# UTILS 

def systemCheck(cmd):
    sys.stderr.write("Executing:" + cmd + "\n")
    sys.stderr.flush()

    subprocess.check_call(cmd, shell=True)

@contextmanager
def open_gzip_or_plain(file_path):

    def decode_text(file_handler):
        for line in file_handler:
            yield line.decode('utf-8')

    f = None
    try:
        #print("file_path", file_path)
        if file_path[-3:] == ".gz":
            f = gzip.open(file_path, 'rb')
            yield decode_text(f)
        elif file_path[-3:] == ".xz":
            f = lzma.open(file_path, 'rb')
            yield decode_text(f)
        else:
            f = open(file_path, 'r')
            yield f

    except Exception:
        raise Exception("Error occured while loading a file {}".format(file_path))

    finally:
        if f:
            f.close()


###########################################################

BITEXTOR=config["bitextor"]

LANG1=config["lang1"]
LANG2=config["lang2"]

if LANG1 == "en":
  FLANG=LANG2
else:
  FLANG=LANG1


TMPDIR=config["temp"]
MINQUALITY=config["minquality"]
MAXLINES=config["maxlines"]

#Working paths
permanent=config["permanentDir"]
transient=config["transientDir"]

systemCheck("mkdir -p " + permanent)
systemCheck("mkdir -p " + transient)

with open(transient + "/config.json", "wt") as configFile:
    configFile.write(str(config))

#Dictionary
if "dic" in config:
  DIC=config["dic"]
else:
  DIC=None

#Option to use the NLTK tokenizer
if "nltk" in config and (config["nltk"]==True):
  USENLTK='--nltk'
else:
  USENLTK=''

#Option to ignore Boilerpipie: if the option is enabled, boilerpipe is not used
if "ignore-boilerpipe-cleaning" in config and config["ignore-boilerpipe-cleaning"]==True:
  IGNOREBOILER="1"
else:
  IGNOREBOILER="0"

#Option to use the JHU-pipeline pre-processing tool; it can be only used with HTTrack
if "jhu-lett" in config and config["jhu-lett"]==True:
  LETT="jlett"
else:
  LETT="lett"

#Option to use HTTrack for crawling instead of the native bitextor crawler
if "httrack" in config and config["httrack"]==True:
  CRAWLTARGET="httrack"
else:
  CRAWLTARGET="creepy"

############ OPTIONS FOR THE NATIVE BITEXTOR CRAWLER ############

#If this option is enabled the crawler will keep crawling across a whole top-level domain (.es, .com, .fr, etc.)
if "crawlTld" in config and config["crawlTld"]==True:
  TLD_CRAWL="-D"
else:
  TLD_CRAWL=""

#If this option is enabled, a size-limit is set for crawled data (for example "size-limit": "1G")
if "size-limit" in config:
  CRAWLSIZELIMIT="-s "+config["size-limit"]
else:
  CRAWLSIZELIMIT=""

#If this option is enabled, a time-limit is set for crawling data (for example "time-limit": "1h")
if "crawlTimeLimit" in config:
  CRAWLTIMELIMIT="-t "+config["crawlTimeLimit"]
else:
  CRAWLTIMELIMIT=""

#Option to set how many threads will be used for crawling (default value: 2). Note that too many threads can cause the server hosting the website to reject some of the simultaneous connections.
if "crawlerNumThreads" in config:
  CRAWLJOBS="-j "+str(config["crawlerNumThreads"])
else:
  CRAWLJOBS="-j 2"

#Connection timeout in the crawler
if "timeout-crawl" in config:
  CRAWLTIMEOUT="-o "+config["timeout-crawl"]
else:
  CRAWLTIMEOUT=""

#If this option is set, the "crawler" object will be dump as a pickle, so crawling can be continued afterwards
if "write-crawling-file" in config:
  CRAWLDUMPARGS="-d "+config["write-crawling-file"]
else:
  CRAWLDUMPARGS=""

#If this option is set, crawling will be continued from the pickle object dumped in a previous crawl
if "continue-crawling-file" in config:
  CONTINUECRAWL="-l "+config["continue-crawling-file"]
else:
  CONTINUECRAWL=""


############ OPTIONS FOR THE MALIGN ALIGNER ############

if "paracrawl-aligner-command" in config:
  MT_COMMAND=config["paracrawl-aligner-command"]

  if MT_COMMAND == "marek-nmt":
      DOCALIGNEXT="marek"
  else:
      DOCALIGNEXT="marek-customMT"
else:
  MT_COMMAND=""
  DOCALIGNEXT="bitextor"

if "bleualign" in config and config["bleualign"]:
  SEGMENTALIGNER="bleualign"
else:
  SEGMENTALIGNER="hunalign"

#This options can be added to the config fil
DOC_THRESHOLD=0
BLEU_THRESHOLD=0

############ FILTERING AND POST-PROCESSING OPTIONS ############

if "bicleaner" in config:
  BICLEANEROPTION=",bicleaner"
  BICLEANER="bicleaner"
  BICLEANER_CONFIG=config["bicleaner"]
else:
  BICLEANEROPTION=""
  BICLEANER="segclean"

if "bicleanerThreshold" in config:
  BICLEANER_THRESHOLD=config["bicleanerThreshold"]
else:
  BICLEANER_THRESHOLD=0.0

if "elrc" in config and config["elrc"]==True:
  ELRCSCORES="elrc"
  ELRCFIELDS=",lengthratio,numTokensSL,numTokensTL,idnumber"
else:
  ELRCSCORES=BICLEANER
  ELRCFIELDS=""

#========================= MAPPING URLS AND OUTPUT FILES =========================#

def createDomainMap(urls):
    domains={}
    for url in urls:
        domain = tldextract.extract(url).domain
        if domain not in domains:
            domains[domain]=[]
        domains[domain].append(url)
        #print("subdomain", domain, url)
    return domains

def loadDomains(file_path):
    domains = set()
    with file_path.open("r") as f:
        for line in f:
            line = line.strip()
            if len(line):
                domains.add(line)

    return domains

def getFullDomainsFromLangstat(langstat_path, lang1, lang2, threshold, exclude_path):
    print("langstat_path", langstat_path, file=sys.stderr)
    l12 = [lang1.lower(), lang2.lower()]

    excluded_set = set()
    if exclude_path:
        excluded_set = loadDomains(Path(exclude_path))

    domains_to_crawl = []

    sys.stderr.write(
        "Gathering domain information for {0} and {1}...\n".format(*l12))
    with tqdm(total=None) as pbar:
        with open_gzip_or_plain(langstat_path) as f:

            prevDomain = ""
            langContent = {}

            for line in f:
                split_line = line.strip().split()
                if len(split_line) != 3:
                    continue

                domain, lang, byte_len = split_line
                name = tldextract.extract(domain).domain
                #print("processing ", domain, lang.lower(), byte_len, name)

                if domain != prevDomain:
                    # start of new domain. Process previous entries
                    if len(langContent) == 2:
                        lang1_bytes = langContent[l12[0]]
                        lang2_bytes = langContent[l12[1]]
                        if lang1_bytes >= threshold and lang2_bytes >= threshold:
                            domains_to_crawl.append(prevDomain)

                    prevDomain = domain
                    langContent = {}

                if lang.lower() in l12 and name not in excluded_set:
                    langContent[lang.lower()] = int(byte_len)

                pbar.update(1)

            # last domain
            if len(langContent) == 2:
                lang1_bytes = langContent[l12[0]]
                lang2_bytes = langContent[l12[1]]
                if lang1_bytes >= threshold and lang2_bytes >= threshold:
                    domains_to_crawl.append(prevDomain)


    print(len(domains_to_crawl), " domains found", file=sys.stderr)
    return domains_to_crawl

if "domains" in config:
    print("domains given")
    domains = config["domains"]
    print("domains", type(domains))
elif os.path.isfile(permanent + "/domains.gz"):
    print("read domains from file")

    with gzip.open(permanent + "/domains.gz", 'rt') as f:
        domains = f.read().splitlines()

elif "langstat" in config:
    print("find domains in langstat")
    langstat_path = config["langstat"]
    lang1 = config["lang1"]
    lang2 = config["lang2"]
    threshold = int(config["langstatThreshold"])
    exclude_path = config["langstatExcludeDomains"]

    domains = getFullDomainsFromLangstat(langstat_path, lang1, lang2, threshold, exclude_path)

    with gzip.open(permanent + "/domains.gz", 'wt') as f:
        for item in domains:
            f.write("%s\n" % item)
else:
    print("Need list of urls or langstat file")
    exit()

domain_2_fulldomains = createDomainMap(domains)
#print("domains", domains)
#print("domain_2_fulldomains", domain_2_fulldomains)

#================================== START SNAKEMAKE================================#

#================================== TARGET FILES ==================================#

OUTPUT=[]

#Two WARC files with documents in lang1 and lang2
OUTPUT.append("{dir}/crawl.{lang}".format(dir=permanent, lang=LANG1))
OUTPUT.append("{dir}/crawl.{lang}".format(dir=permanent, lang=LANG2))

OUTPUT.append("{dir}/evaluation/report".format(dir=config["nmtTransientDir"]))
OUTPUT.append("{dir}/evaluation/report".format(dir=config["nmtCrawlTransientDir"]))

#Optional TMX: if option enabled, TMX is generated; otherwhise, tab-separated .sent file is generated
if "tmx" in config and config["tmx"]:
    OUTPUT.append("{dir}/{l1}-{l2}.tmx".format(dir=permanent, l1=LANG1, l2=LANG2))
else:
    OUTPUT.append("{dir}/{l1}-{l2}.sent".format(dir=permanent, l1=LANG1, l2=LANG2))

rule all:
    input:
        expand("{target}", target=OUTPUT)

#================================== NMT ======================================#

rule train_nmt_with_crawl_data:
    input:
        l1="{dir}/crawl.{lang}".format(dir=permanent, lang=LANG1)
        ,
        l2="{dir}/crawl.{lang}".format(dir=permanent, lang=LANG2)
    priority: 50

    output:
        report = "{dir}/nmt-dir/evaluation/report".format(dir=transient)
    run:
        trainData = config["nmtTrainPrefix"]

        crawlPref = "{dir}/crawl".format(dir=permanent)
        trainData.append(crawlPref)

        cmd = "snakemake --snakefile {BITEXTOR}/snakemake/nmt/Snakefile --configfile {transient}/config.json -k -j3" \
            + " --directory {transient}/nmt-dir-crawl" \
            + " --config nmtTrainPrefix=\"" + str(trainData) + "\"" \
            + " permanentDir={permanent}/nmt-dir-crawl"
        print("cmd", cmd)
        shell(cmd)

rule train_nmt_all:
    output:
        report = "{dir}/nmt-dir/evaluation/report".format(dir=transient)
    priority: 50
    run:
        cmd = "snakemake --snakefile {BITEXTOR}/snakemake/nmt/Snakefile --configfile {transient}/config.json -k -j3" \
            + " --directory {transient}/nmt-dir" \
            + " --config permanentDir={permanent}/nmt-dir"
        shell(cmd)

#================================== CRAWLING ======================================#
#"http://www.elenacaffe1863.com/", "http://elenacaffe1863.com/", "http://vade-retro.fr"
rule creepy_download:
    params:
        url="http://{target}"
    output:
        '{dir}/warc'.format(dir=permanent)+'/{target}.creepy.warc.xz'
    priority: 10
    shell:
        'echo {params.url}'
        'mkdir -p {permanent}; '
        'python3 {BITEXTOR}/bitextor-crawl.py {TLD_CRAWL} {CRAWLSIZELIMIT} {CRAWLTIMELIMIT} {CRAWLJOBS} {CRAWLTIMEOUT} {CRAWLDUMPARGS} {CONTINUECRAWL} {params.url} | xz -c > {output}'

rule httrack_download:
    output:
        '{dir}/warc'.format(dir=permanent)+'/{target}.httrack.warc.xz'
    params:
        url="http://{target}"
    priority: 10
    shell:
        'mkdir -p {permanent}; '
        'DIRNAME=$(mktemp -d {TMPDIR}/downloaded_websites.XXXXXX); '
        '{BITEXTOR}/bitextor-downloadweb.py --url {params.url} --output-path $DIRNAME {CRAWLTIMELIMIT}; '
        '{BITEXTOR}/bitextor-webdir2warc.sh $DIRNAME | xz -c > {output}; '
        'rm -rf $DIRNAME;'

rule concat_subdomains:
    input:
        lambda w: expand('{dir}/warc/{subdomain}.{crawler}.warc.xz', dir=permanent, subdomain=domain_2_fulldomains[w.target], crawler=CRAWLTARGET)
    output:
        "{dir}".format(dir=transient)+"/{target}.concat.warc.xz"
    shell:
        'xzcat {input} | xz -c > {output}'

rule warc2tt:
    input:
        '{target}.concat.warc.xz'
    output:
        '{target}.tt'
    shell:
        'xzcat {input} | {BITEXTOR}/bitextor-warc2tt.py > {output}'

rule tt2ttmime:
    input:
        '{target}.tt'
    output:
        '{target}.ttmime'
    shell:
        '{BITEXTOR}/bitextor-identifyMIME.py < {input} > {output}'

rule tt2xtt:
    input:
        #If HTTRACK is enalbed, httrack rule is run; otherwise, download rule is applied
        '{target}.ttmime'
    output:
        '{target}.xtt'
    shell:
        '{BITEXTOR}/bitextor-get-html-text.py -x < {input} > {output}'

#This rule won't work with current non-installation configuration
rule xtt2boiler:
    input:
        '{target}.xtt'
    output:
        '{target}.boiler'
    shell:
        "if [ \"{IGNOREBOILER}\" == \"1\" ]; then "
        "  java -Dfile.encoding=UTF-8 -jar {BITEXTOR}/share/java/piped-boilerpipe.jar < {input} > {output}; "
        "else "
        "  cat {input} > {output}; "
        "fi"

rule boiler2ett:
    input:
        '{target}.boiler'
    output:
        '{target}.ett'
    shell:
        '{BITEXTOR}/bitextor-dedup.py < {input} > {output}'

rule ett2tika:
    input:
        '{target}.ett'
    output:
        '{target}.tika'
    shell:
        '{BITEXTOR}/bitextor-get-html-text.py -t < {input} > {output}'

rule ett2lett:
    input:
        '{target}.tika'
    output:
        '{target}.lett'
    shell:
        '{BITEXTOR}/bitextor-lett-language-detector.py -l {LANG1},{LANG2} < {input} > {output}'

rule httrack2lett:
    output:
        '{target}.jlett'
    input:
        '{target}.tar'
    shell:
        '{BITEXTOR}/tar2lett {input} {LANG1} {LANG2} > {output}'

rule lett2lettr:
    input:
        expand("{{target}}.{extension}", extension=LETT)
    output:
        '{target}.lettr'
    shell:
        '{BITEXTOR}/bitextor-lett2lettr.py < {input} > {output}'

rule lettr2idx:
    input:
        '{target}.lettr'
    output:
        '{target}.idx'
    shell:
        '{BITEXTOR}/bitextor-lett2idx.py  --lang1 {LANG1} --lang2 {LANG2} -m 15 < {input} > {output}'




#================================== DOCUMENT ALIGNMENT ==================================#

rule idx2ridx_l1tol2:
    input:
        '{target}.idx'
    output:
        '{target}.1.ridx'
    shell:
        '{BITEXTOR}/bitextor-idx2ridx.py -d {DIC} --lang1 {LANG1} --lang2 {LANG2} < {input} > {output}'

rule idx2ridx_l2tol1:
    input:
        '{target}.idx'
    output:
        '{target}.2.ridx'
    shell:
        '{BITEXTOR}/bitextor-idx2ridx.py -d {DIC} --lang1 {LANG2} --lang2 {LANG1}  < {input} > {output}'

rule ridx2imagesetoverlap:
    input:
        '{target}.{num}.ridx',
        '{target}.lettr'
    output:
        '{target}.{num}.imgoverlap'
    shell:
        '{BITEXTOR}/features/bitextor-imagesetoverlap.py -l {wildcards.target}.lettr < {input[0]} > {output}'

rule imagesetoverlap2structuredistance:
    input:
        '{target}.{num}.imgoverlap',
        '{target}.lettr'
    output:
        '{target}.{num}.structuredistance'
    shell:
        '{BITEXTOR}/features/bitextor-structuredistance.py -l {wildcards.target}.lettr < {input[0]} > {output}'

rule structuredistance2urldistance:
    input:
        '{target}.{num}.structuredistance',
        '{target}.lettr'
    output:
        '{target}.{num}.urldistance'
    priority: 8
    shell:
        '{BITEXTOR}/features/bitextor-urlsdistance.py -l {wildcards.target}.lettr < {input[0]} > {output}'

rule urldistance2mutuallylinked:
    input:
        '{target}.{num}.urldistance',
        '{target}.lettr'
    output:
        '{target}.{num}.mutuallylinked'
    shell:
        '{BITEXTOR}/features/bitextor-mutuallylinked.py -l {wildcards.target}.lettr < {input[0]} > {output}'

rule mutuallylinked2urlscomparison:
    input:
        '{target}.{num}.mutuallylinked',
        '{target}.lettr'
    output:
        '{target}.{num}.urlscomparison'
    shell:
        '{BITEXTOR}/features/bitextor-urlscomparison.py -l {wildcards.target}.lettr < {input[0]} > {output}'

rule urlscomparison2urlsoverlap:
    input:
        '{target}.{num}.urlscomparison',
        '{target}.lettr'
    output:
        '{target}.{num}.urlsoverlap'
    shell:
        '{BITEXTOR}/features/bitextor-urlsetoverlap.py -l {wildcards.target}.lettr < {input[0]} > {output}'

rule urlsoverlap2rank:
    input:
        '{target}.{num}.urlsoverlap',
        '{target}.lettr'
    output:
        '{target}.{num}.rank'
    shell:
        '{BITEXTOR}/bitextor-rank.py -m {BITEXTOR}/share/bitextor/model/keras.model -w {BITEXTOR}/share/bitextor/model/keras.weights < {input[0]} > {output}'

rule aligndocumentsMarek:
    input:
        "{target}.lett",
        "{dir}/nmt-dir/evaluation/report".format(dir=transient)

    output:
        '{target}.docalign.marek'
    priority: 40

    shell:
        'mkdir -p {wildcards.target}.docalign; '
        '{BITEXTOR}/document-aligner/doc_align.sh -f {input[0]} -l {LANG2} -t "{BITEXTOR}/snakemake/nmt/translate.sh {transient}/config.json {wildcards.target}.docalign {permanent}/nmt-dir" -d -w {wildcards.target}.docalign > {output}'

rule aligndocumentsMarekCustomMT:
    input:
        "{target}.lett",

    output:
        '{target}.docalign.marek-customMT'
    shell:
        'mkdir -p {wildcards.target}.docalign; '
        '{BITEXTOR}/document-aligner/doc_align.sh -f {input[0]} -l {LANG2} -t "{MT_COMMAND}" -d -w {wildcards.target}.docalign > {output[0]}'

rule aligndocumentsBitextor:
    input:
        '{target}.1.rank',
        '{target}.2.rank',
        '{target}.lettr'
    output:
        '{target}.docalign.bitextor'
    shell:
        '{BITEXTOR}/bitextor-align-documents.py -l {input[2]} -n 1 -i converge -r /dev/null {input[0]} {input[1]} > {output}'

rule hunaligndic:
    input:
        expand("{dic}", dic=DIC)
    output:
        '{dir}/hunalign_dic'.format(dir=transient)
    shell:
        'tail -n +2 {input} | sed -r "s/\t/ @ x/g" > {output}'



#================================== SEGMENT ALIGNMENT ==================================#

rule alignsegments_hunalign:
    input:
        '{dir}/hunalign_dic'.format(dir=transient),
        "{name}.docalign."+"{extension}".format(extension=DOCALIGNEXT)
    output:
        '{name}.hunalign.segalign'
    shell:
        '{BITEXTOR}/bitextor-align-segments.py -d {input[0]} -t {TMPDIR} --lang1 {LANG1} --lang2 {LANG2} {USENLTK} --hunalign-dir "{BITEXTOR}/bin" < {input[1]} > {output}'

rule alignsegments_bleualign:
    input:
        "{name}.docalign."+"{extension}".format(extension=DOCALIGNEXT)
    output:
        '{name}.bleualign.segalign'
    shell:
        '{BITEXTOR}/bleualign.sh {wildcards.name}.lett {FLANG} {wildcards.name}.docalign {DOC_THRESHOLD} {BLEU_THRESHOLD} {output}'

rule concat_segs:
    input:
        expand("{{dir}}/{webdomain}.{segaligner}.segalign", webdomain=domain_2_fulldomains.keys(), segaligner={SEGMENTALIGNER})
    output:
        "{dir}/{l1}-{l2}.sentalg"
    shell:
        "cat {input} > {output}"

rule cleansegments:
    input:
        "{dir}/{l1}-{l2}.sentalg"
    output:
        "{dir}/{l1}-{l2}.segclean"
    shell:
        '{BITEXTOR}/bitextor-cleantextalign.py -q {MINQUALITY} -m {MAXLINES} -s < {input} > {output}'

#================================== POST PROCESSING ==================================#

#NOTE: did not add zipporah since it will be deprecated in version 7 of bitextor
#TODO: Add Bicleaner, add deduplication

rule bicleaner:
    input:
        "{dir}/{l1}-{l2}.segclean"
    output:
        "{dir}/{l1}-{l2}.bicleaner.scores"
    shell:
        'python3  {BITEXTOR}/bicleaner_classifier_full.py --threshold {BICLEANER_THRESHOLD} {input} {output} {BICLEANER_CONFIG}'

rule bicleanerfilter:
    input:
        "{dir}/{l1}-{l2}.bicleaner.scores"
    output:
        "{dir}/{l1}-{l2}.bicleaner"
    shell:
        '{BITEXTOR}/bitextor-filterbicleaner.py --threshold {BICLEANER_THRESHOLD} < {input} > {output}'

rule elrc:
    input:
        "{dir}/{l1}-{l2}."+"{extension}".format(extension=BICLEANER)
    output:
        "{dir}/{l1}-{l2}.elrc"
    shell:
        '{BITEXTOR}/bitextor-elrc-filtering.py -c "url1,url2,seg1,seg2,hunalign{BICLEANEROPTION}" -s < {input} > {output}'

rule sents:
    input:
        "{dir}".format(dir=config["transientDir"])+"/{l1}-{l2}."+"{ext}".format(ext=ELRCSCORES)
    output:
        "{dir}".format(dir=config["permanentDir"])+"/{l1}-{l2}.sent"
    shell:
        "cp {input} {output}"


rule tmx:
    input:
        "{dir}".format(dir=config["transientDir"])+"/{l1}-{l2}."+"{ext}".format(ext=ELRCSCORES)
    output:
        "{dir}".format(dir=config["permanentDir"])+"/{l1}-{l2}.tmx"
    shell:
        "{BITEXTOR}/bitextor-buildTMX.py --lang1 {LANG1} --lang2 {LANG2} -c url1,url2,seg1,seg2,hunalign{BICLEANEROPTION}{ELRCFIELDS} < {input} > {output}"

rule mt_parallel_data:
    input:
         "{dir}/{l1}-{l2}.sent".format(dir=permanent, l1=LANG1, l2=LANG2)
    output:
         l1="{dir}/crawl.{lang}".format(dir=permanent, lang=LANG1)
         ,
         l2="{dir}/crawl.{lang}".format(dir=permanent, lang=LANG2)
    shell:
         "cat {input} | cut -f 3,4 | sort | uniq > corpus; "
         "cut -f 1 corpus > {output.l1} && cut -f 2 corpus > {output.l2}; "
         "rm corpus"
